// auto-generated by make.py
pub mod ic; // the unsafe wrappers
pub mod codec;
pub mod generic;
pub mod sample;

pub mod p4 {

    use crate::ic;

    /// Turbopfor encode unsorted integer lists of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u128v64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc128v64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc128v64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u256w32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn enc256w32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nenc256w32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndec8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4ndec16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4ndec32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::p4ndec64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4ndec128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4ndec128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec128v64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::p4ndec128v64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dec256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4ndec256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for increasing integer lists (sorted w/ duplicate) of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn denc256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4ndenc256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nddec8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4nddec16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nddec32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::p4nddec64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4nddec128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nddec128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nddec256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn ddec256w32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nddec256w32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode delta for strictly increasing integer lists (sorted unique) of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1enc256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1enc256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nd1dec8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4nd1dec16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nd1dec32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::p4nd1dec64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4nd1dec128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nd1dec128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode delta for strictly increasing integer lists (sorted unique) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1dec256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nd1dec256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor encode ZigZag for unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zenc256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzenc256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::p4nzdec8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4nzdec16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nzdec32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::p4nzdec64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::p4nzdec128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nzdec128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Turbopfor decode ZigZag for unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zdec256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::p4nzdec256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

} // ends mod p4

pub mod bit {

    use crate::ic;

    /// Bit packing pack unsorted integer lists of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u128v64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack128v64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack128v64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn pack256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnpack256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnunpack8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnunpack16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnunpack32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::bitnunpack64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnunpack128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnunpack128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack128v64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::bitnunpack128v64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn unpack256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnunpack256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for increasing integer lists (sorted w/ duplicate) of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn dpack256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndpack256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitndunpack8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitndunpack16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitndunpack32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::bitndunpack64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitndunpack128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitndunpack128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for increasing integer lists (sorted w/ duplicate) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn dunpack256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitndunpack256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack delta for strictly increasing integer lists (sorted unique) of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn d1pack256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1pack256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnd1unpack8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnd1unpack16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnd1unpack32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::bitnd1unpack64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnd1unpack128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnd1unpack128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack delta for strictly increasing integer lists (sorted unique) into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn d1unpack256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnd1unpack256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack sorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn fpack256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfpack256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnfunpack8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnfunpack16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnfunpack32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::bitnfunpack64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnfunpack128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnfunpack128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack sorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn funpack256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnfunpack256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u8`.
    /// # Arguments
    /// * `input` - `&[u8]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack8(input: &[u8], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack8(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u64`.
    /// # Arguments
    /// * `input` - `&[u64]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack64(input: &[u64], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack64(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u16`.
    /// # Arguments
    /// * `input` - `&[u128v16]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack128v16(input: &[u16], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack128v16(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u128v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack128v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack128v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing pack ZigZag for unsorted integer lists of `u32`.
    /// # Arguments
    /// * `input` - `&[u256v32]` containing the uncompressed input
    /// * `output` - `&[u8]` containing the compressed output
    /// # Returns
    /// Number of bytes written to output
    pub fn zpack256v32(input: &[u32], output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzpack256v32(input.as_ptr(), input.len(), output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u8` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u8]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack8(input: &[u8], output_len: usize, output: &mut [u8]) -> usize
    {
        unsafe {
            ic::bitnzunpack8(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnzunpack16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnzunpack32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u64` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u64]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack64(input: &[u8], output_len: usize, output: &mut [u64]) -> usize
    {
        unsafe {
            ic::bitnzunpack64(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u16` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u16]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack128v16(input: &[u8], output_len: usize, output: &mut [u16]) -> usize
    {
        unsafe {
            ic::bitnzunpack128v16(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack128v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnzunpack128v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

    /// Bit packing unpack ZigZag for unsorted integer lists into `u32` list
    /// # Arguments
    /// * `input` - `[u8]` containing the compressed input
    /// * `output_len` - Length of decompressed data to be written to output
    /// * `output` - `&[u32]` containing the decompressed output
    /// # Returns
    /// Number of bytes read from input
    pub fn zunpack256v32(input: &[u8], output_len: usize, output: &mut [u32]) -> usize
    {
        unsafe {
            ic::bitnzunpack256v32(input.as_ptr(), output_len, output.as_mut_ptr())
        }
    }

} // ends mod bit
#[cfg(test)]
mod test;
